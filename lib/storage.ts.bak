import { NewsletterContent } from '@/types/newsletter';
import { parseDateToISOString } from '@/utils/dateService';
import { redisClient } from '@/lib/redisClient';
import logger from '@/utils/logger';
import { SCHEMA } from './constants';

// Local type definitions
type Newsletter = {
  id: string;
  subject: string;
  from: string;
  date: string;
  body: string;
  html?: string;
  text?: string;
  read?: boolean;
  archived?: boolean;
  tags?: string[];
  rawContent?: string;
  compressionRatio?: number;
  hasFullContent: boolean;
  cleanContent?: string;
  summary?: string;
  metadata?: {
    processingVersion?: string;
    processedAt?: string;
    isRead?: boolean;
    archived?: boolean;
  };
};

/**
 * Interface for newsletter metadata stored in Redis
 * This combines both schema versions for backward compatibility
 */
interface NewsletterMetadata {
  // Required fields
  id: string;
  subject: string;
  from: string;
  date: string;
  hasFullContent: boolean;
  
  // Optional fields
  sender?: string;  // Alias for 'from' in some contexts
  url?: string;     // Old schema field
  content?: string; // Old schema field
  read?: boolean;
  archived?: boolean;
  tags?: string[];
  summary?: string;
  cleanContent?: string;
  rawContent?: string;
  compressionRatio?: number;
  
  // Nested metadata
  metadata?: {
    processingVersion?: string;
    processedAt?: string;
    isRead?: boolean;
    archived?: boolean;
  };
}

// Use the singleton Redis client instance
const redis = redisClient;

export class NewsletterStorage {
  // Schema constants are now used directly

  /**
   * Helper function to safely parse boolean values from various formats
   */
  private static parseBoolean(value: unknown, defaultValue = false): boolean {
    // Handle boolean values directly
    if (value === true || value === false) return value;
    
    // Handle string values
    if (typeof value === 'string') {
      const normalized = value.toLowerCase().trim();
      const truthyValues = new Set(['true', '1', 'yes', 'y', 'on']);
      const falsyValues = new Set(['false', '0', 'no', 'n', 'off']);
      
      if (truthyValues.has(normalized)) return true;
      if (falsyValues.has(normalized)) return false;
      return defaultValue;
    }
    
    // Handle numeric values
    if (typeof value === 'number') {
      return value === 1;
    }
    
    // Return default if type is not handled
    return defaultValue;
  }

  /**
   * Generate a summary from content
   */
  private static generateSummary(content: string, maxLength = 200): string {
    if (!content) return '';
    const plainText = content.replace(/<[^>]*>?/gm, '');
    return plainText.length > maxLength
      ? plainText.substring(0, maxLength) + '...'
      : plainText;
  }

  /**
   * Migrate a single newsletter from old schema to new schema
   */
  private static async migrateToNewSchema(newsletter: Partial<Newsletter>): Promise<void> {
    try {
      const id = newsletter.id;
      if (!id) {
        logger.warn('Cannot migrate newsletter without ID');
        return;
      }

      const metaKey = `${SCHEMA.META_PREFIX}${id}`;

      // Skip if already migrated
      const exists = await redis.exists(metaKey);
      if (exists) {
        logger.debug(`Newsletter ${id} already migrated, skipping`);
        return;
      }

      // Prepare metadata with defaults
      const body = newsletter.body || '';
      const hasFullContent = newsletter.hasFullContent ?? !!body;
      const now = new Date().toISOString();

      // Create a properly typed newsletter object with all required fields
      const baseMetadata = (typeof newsletter.metadata === 'object' ? newsletter.metadata : {}) as Partial<Newsletter['metadata']>;
      
      // Create normalized metadata with proper types and defaults
      const metadata: Newsletter['metadata'] = {
        processingVersion: '1.0',
        processedAt: now,
        isRead: false,
        archived: false,
        ...baseMetadata
      };
      
      // Ensure boolean values are properly set
      metadata.isRead = NewsletterStorage.parseBoolean(metadata.isRead, false);
      metadata.archived = NewsletterStorage.parseBoolean(metadata.archived, false);
      
      // Ensure boolean values are properly typed
      const isRead = Boolean(metadata.isRead);
      const isArchived = Boolean(metadata.archived);
      
      const fullNewsletter: Newsletter = {
        id,
        subject: newsletter.subject || '',
        from: newsletter.from || '',
        date: newsletter.date || now,
        body: body,
        html: newsletter.html || '',
        text: newsletter.text || '',
        cleanContent: newsletter.cleanContent || '',
        rawContent: newsletter.rawContent || '',
        read: isRead,
        archived: isArchived,
        metadata,
        hasFullContent,
        compressionRatio: newsletter.compressionRatio,
        tags: newsletter.tags
      };

      logger.debug(`Migrating newsletter ${id} to new schema`);
      
      // Store using storeNewsletter which handles both schemas
      await this.storeNewsletter(fullNewsletter);
      logger.info(`Successfully migrated newsletter ${id} to new schema`);
    } catch (error) {
      logger.error('Error migrating newsletter to new schema:', error);
      throw error;
    }
  }

  /**
   * Combine metadata and content into a single newsletter object
   */
  /**
   * Store a newsletter in both old and new schemas
   */
  static async storeNewsletter(newsletter: Newsletter): Promise<void> {
    try {
      const { id } = newsletter;
      if (!id) throw new Error('Newsletter ID is required');

      const metaKey = `${SCHEMA.META_PREFIX}${id}`;
      const oldKey = `${SCHEMA.NEWSLETTER_PREFIX}${id}`;
      const contentKey = `newsletter:content:${id}`;

      // Ensure hasFullContent is set based on content presence
      const hasFullContent = newsletter.hasFullContent ?? !!newsletter.body;
      
      // Prepare metadata for new schema, filtering out null/undefined values
      const metadata: Record<string, any> = {
        id,
        subject: newsletter.subject || '',
        from: newsletter.from || '',
        date: newsletter.date || new Date().toISOString(),
        hasFullContent,
        summary: this.generateSummary(newsletter.body || '')
      };

      // Only add optional fields if they have values
      if (newsletter.metadata) metadata.metadata = JSON.stringify(newsletter.metadata);
      if (newsletter.cleanContent) metadata.cleanContent = newsletter.cleanContent;
      if (newsletter.rawContent) metadata.rawContent = newsletter.rawContent;
      if (newsletter.compressionRatio) metadata.compressionRatio = newsletter.compressionRatio;
      if (newsletter.tags) metadata.tags = JSON.stringify(newsletter.tags);

      // Store in new schema
      await Promise.all([
        // Filter out undefined/null values from metadata before storing
        redis.hset(metaKey, Object.fromEntries(
          Object.entries(metadata).filter(([_, v]) => v != null)
        ) as Record<string, string>),
        redis.set(contentKey, newsletter.body || '')
      ]);

      // Also store in old schema for backward compatibility
      await redis.set(oldKey, JSON.stringify({
        ...newsletter,
        hasFullContent
      }));

      // Add to IDs list if not exists
      await redis.lrem(SCHEMA.NEWSLETTER_IDS_KEY, 0, id);
      await redis.lpush(SCHEMA.NEWSLETTER_IDS_KEY, id);

    } catch (error) {
      logger.error('Error storing newsletter:', error);
      throw error;
    }
  }

  /**
   * Combines newsletter metadata and content into a single Newsletter object
   */
  private static combineNewsletterData(
    metadata: Partial<NewsletterMetadata> | null,
    content: string | null = null
  ): Newsletter | null {
    // Early return for invalid metadata
    if (!metadata || !metadata.id) {
      logger.warn('Invalid or missing metadata in combineNewsletterData');
      return null;
    }

    try {
      const contentValue = content || metadata.content || '';
      const cleanContent = metadata.cleanContent || contentValue;
      const rawContent = metadata.rawContent || contentValue;
      const hasContent = contentValue.length > 0 || cleanContent.length > 0 || rawContent.length > 0;
      
      // Handle metadata with proper type safety
      const metadataObj: Partial<Newsletter['metadata']> = 
        metadata.metadata && typeof metadata.metadata === 'object' 
          ? metadata.metadata 
          : {};
      
      // Parse boolean values with defaults
      const isRead = this.parseBoolean(metadataObj.isRead, false);
      const isArchived = this.parseBoolean(metadataObj.archived, false);
      
      // Create metadata with proper types
      const meta: Newsletter['metadata'] = {
        processingVersion: '1.0',
        processedAt: new Date().toISOString(),
        ...metadataObj,
        isRead,
        archived: isArchived
      };
      
      // Create the newsletter object with proper typing
      return {
        id: metadata.id,
        subject: metadata.subject || '',
        from: metadata.from || metadata.sender || '',
        date: metadata.date || new Date().toISOString(),
        body: contentValue,
        cleanContent,
        rawContent,
        hasFullContent: hasContent,
        summary: metadata.summary || this.generateSummary(contentValue),
        tags: metadata.tags,
        compressionRatio: metadata.compressionRatio,
        read: isRead,
        archived: isArchived,
        metadata: meta
      };
    } catch (error) {
      logger.error('Error processing newsletter data:', error);
      continue; // Skip this newsletter but continue processing others
    }

/**
 * Process a list of old format newsletter keys
 */
private static async processOldFormatNewsletters(keys: string[]): Promise<NewsletterMetadata[]> {
  const newsletters: NewsletterMetadata[] = [];
  
  for (const key of keys) {
    try {
      // Extract ID from key (remove 'newsletter:' prefix)
      const id = key.substring('newsletter:'.length);
      const oldData = await redis.get(key);
      
      if (!oldData) {
        logger.warn(`No data found for key: ${key}`);
        continue;
      }
      
      // Parse the old data
      const parsed = typeof oldData === 'string' ? JSON.parse(oldData) : oldData;
      
      // Handle metadata parsing with proper type safety
      const defaultMetadata: Newsletter['metadata'] = {
        processingVersion: '1.0',
        processedAt: new Date().toISOString(),
        isRead: this.parseBoolean(parsed.read, false),
        archived: this.parseBoolean(parsed.archived, false)
      };
      
      // Parse metadata with proper type safety and fallbacks
      let parsedMetadata: Partial<Newsletter['metadata']> = {};
      if (parsed.metadata) {
        try {
          const rawMetadata = typeof parsed.metadata === 'string' 
            ? JSON.parse(parsed.metadata) 
            : parsed.metadata;
          
          // Safely merge with type checking
          parsedMetadata = {
            processingVersion: rawMetadata.processingVersion,
            processedAt: rawMetadata.processedAt,
            isRead: rawMetadata.isRead,
            archived: rawMetadata.archived
          };
        } catch (e) {
          logger.warn(`Failed to parse metadata for ${id}:`, e);
        }
      }
      
      // Create newsletter metadata from old format
      const newsletter: NewsletterMetadata = {
        id: parsed.id || id,
        subject: parsed.subject || 'No subject',
        from: parsed.from || parsed.sender || 'Unknown sender',
        date: parsed.date || new Date().toISOString(),
        sender: parsed.sender,
        url: parsed.url,
        content: parsed.content || parsed.body,
        cleanContent: parsed.cleanContent,
        rawContent: parsed.rawContent,
        hasFullContent: !!(parsed.content || parsed.body),
        read: parsed.read,
        archived: parsed.archived,
        tags: parsed.tags,
        compressionRatio: parsed.compressionRatio,
        metadata: {
          processingVersion: parsedMetadata.processingVersion || defaultMetadata.processingVersion,
          processedAt: parsedMetadata.processedAt || defaultMetadata.processedAt,
          isRead: this.parseBoolean(parsedMetadata.isRead, defaultMetadata.isRead),
          archived: this.parseBoolean(parsedMetadata.archived, defaultMetadata.archived)
        }
      };
      
      // Generate summary if not present
      if (!newsletter.summary && (newsletter.content || newsletter.cleanContent)) {
        newsletter.summary = this.generateSummary(newsletter.content || newsletter.cleanContent || '');
      }
      
      newsletters.push(newsletter);
      
      // Migrate to new schema in the background
      this.migrateToNewSchema(parsed).catch(err => {
        logger.error(`Error migrating newsletter ${id}:`, err);
      });
      
    } catch (error) {
      logger.error(`Error processing old format newsletter ${key}:`, error);
    }
  }
  
  return newsletters;
}

/**
 * Get metadata for all newsletters
 */
static async getAllNewsletters(): Promise<NewsletterMetadata[]> {
  try {
    logger.debug('Fetching all newsletter data from Redis...');
    
    // First, get all keys that match the old format
    const allKeys = await redis.keys('newsletter:*');
    const oldFormatKeys = allKeys.filter((key: string) => !key.includes(':meta:') && !key.includes(':'));
    logger.debug(`Found ${oldFormatKeys.length} old format newsletter keys`);
    
    // If we have old format keys, process them
    if (oldFormatKeys.length > 0) {
      logger.debug('Processing old format newsletters...');
      return this.processOldFormatNewsletters(oldFormatKeys);
    }
    
    // If no old format keys, try to get from the list
    logger.debug('No old format keys found, trying newsletter IDs list...');
    const listIds = await redis.lrange(SCHEMA.NEWSLETTER_IDS_KEY, 0, -1);
    logger.debug(`Found ${listIds.length} newsletter IDs in list`);
    
    if (listIds.length === 0) {
      logger.debug('No newsletter data found in Redis');
      return [];
    }
    
    return this.processNewsletterList(listIds);
  } catch (error) {
    logger.error('Error in getAllNewsletters:', error);
    return [];
  }
}

/**
 * Process a list of newsletter IDs (new format)
 */
private static async processNewsletterList(ids: string[]): Promise<NewsletterMetadata[]> {
  const newsletters: NewsletterMetadata[] = [];
  
  for (const id of ids) {
    try {
      const metaKey = `${SCHEMA.META_PREFIX}${id}`;
      const contentKey = `newsletter:content:${id}`;
      
      logger.debug(`Processing newsletter ${id} with meta key: ${metaKey}`);
      
      let metadata = await redis.hgetall(metaKey);
      let content = await redis.get(contentKey);
      
      // Fallback to old schema if not found in new schema
      if (!metadata || Object.keys(metadata).length === 0) {
        const oldKey = `${SCHEMA.NEWSLETTER_PREFIX}${id}`;
        logger.debug(`Falling back to old key: ${oldKey}`);
        const oldData = await redis.get(oldKey);
        
        if (oldData) {
          // Convert old format to new format
          const parsed = typeof oldData === 'string' ? JSON.parse(oldData) : oldData;
          await this.migrateToNewSchema(parsed);
          
          // Get the migrated data
          [metadata, content] = await Promise.all([
            redis.hgetall(metaKey),
            redis.get(contentKey)
          ]);
        }
      }
      
      if (!metadata || Object.keys(metadata).length === 0) {
        logger.warn(`No metadata found for newsletter: ${id}`);
        continue;
      }
      
      // Create a proper NewsletterMetadata object
      const newsletterMetadata: NewsletterMetadata = {
        id: metadata.id || id,
        subject: metadata.subject || '',
        from: metadata.from || metadata.sender || 'Unknown Sender',
        date: metadata.date || new Date().toISOString(),
        hasFullContent: this.parseBoolean(metadata.hasFullContent, false),
        content: content || metadata.content || '',
        cleanContent: metadata.cleanContent,
        rawContent: metadata.rawContent,
        summary: metadata.summary,
        read: this.parseBoolean(metadata.read, false),
        archived: this.parseBoolean(metadata.archived, false),
        tags: metadata.tags ? (Array.isArray(metadata.tags) ? metadata.tags : [metadata.tags]) : [],
        compressionRatio: metadata.compressionRatio ? Number(metadata.compressionRatio) : undefined,
        url: metadata.url,
        sender: metadata.sender,
        metadata: typeof metadata.metadata === 'string'
          ? JSON.parse(metadata.metadata)
          : metadata.metadata || {
              processingVersion: '1.0',
              processedAt: new Date().toISOString(),
              isRead: this.parseBoolean(metadata.isRead, false),
              archived: this.parseBoolean(metadata.archived, false)
            }
      };
      
      // Generate summary if not present
      if (!newsletterMetadata.summary && (newsletterMetadata.content || newsletterMetadata.cleanContent)) {
        newsletterMetadata.summary = this.generateSummary(
          newsletterMetadata.content || newsletterMetadata.cleanContent || ''
        );
      }
      
      newsletters.push(newsletterMetadata);
    } catch (error) {
      logger.error('Error processing newsletter data:', error);
      continue; // Skip this newsletter but continue processing others
    }
  }
  
  // Sort newsletters by date (newest first) and return
  return newsletters.sort((a, b) => {
    try {
      const dateA = new Date(a.date);
      const dateB = new Date(b.date);
      return dateB.getTime() - dateA.getTime();
    } catch (error) {
      logger.error('Error sorting newsletters by date:', error);
      return 0;
    }
  });

  /**
   * Process a list of old format newsletter keys
   */
  private static async processOldFormatNewsletters(keys: string[]): Promise<NewsletterMetadata[]> {
    const newsletters: NewsletterMetadata[] = [];
    
    for (const key of keys) {
      try {
        // Extract ID from key (remove 'newsletter:' prefix)
        const id = key.substring('newsletter:'.length);
        const oldData = await redis.get(key);
        
        if (!oldData) {
          logger.warn(`No data found for key: ${key}`);
          continue;
        }
        
        // Parse the old data
        const parsed = typeof oldData === 'string' ? JSON.parse(oldData) : oldData;
        
        // Handle metadata parsing with proper type safety
        const defaultMetadata: Newsletter['metadata'] = {
          processingVersion: '1.0',
          processedAt: new Date().toISOString(),
          isRead: this.parseBoolean(parsed.read, false),
          archived: this.parseBoolean(parsed.archived, false)
        };
        
        // Parse metadata with proper type safety and fallbacks
        let parsedMetadata: Partial<Newsletter['metadata']> = {};
        if (parsed.metadata) {
          try {
            const rawMetadata = typeof parsed.metadata === 'string' 
              ? JSON.parse(parsed.metadata) 
              : parsed.metadata;
            
            // Safely merge with type checking
            parsedMetadata = {
              processingVersion: rawMetadata.processingVersion,
              processedAt: rawMetadata.processedAt,
              isRead: rawMetadata.isRead,
              archived: rawMetadata.archived
            };
          } catch (e) {
            logger.warn(`Failed to parse metadata for ${id}:`, e);
          }
        }
        
        // Create newsletter metadata from old format
        const newsletter: NewsletterMetadata = {
          id: parsed.id || id,
          subject: parsed.subject || 'No subject',
          from: parsed.from || parsed.sender || 'Unknown sender',
          date: parsed.date || new Date().toISOString(),
          sender: parsed.sender,
          url: parsed.url,
          content: parsed.content || parsed.body,
          cleanContent: parsed.cleanContent,
          rawContent: parsed.rawContent,
          hasFullContent: !!(parsed.content || parsed.body),
          read: parsed.read,
          archived: parsed.archived,
          tags: parsed.tags,
          compressionRatio: parsed.compressionRatio,
          metadata: {
            processingVersion: parsedMetadata.processingVersion || defaultMetadata.processingVersion,
            processedAt: parsedMetadata.processedAt || defaultMetadata.processedAt,
            isRead: this.parseBoolean(parsedMetadata.isRead, defaultMetadata.isRead),
            archived: this.parseBoolean(parsedMetadata.archived, defaultMetadata.archived)
          }
        };
        
        // Generate summary if not present
        if (!newsletter.summary && (newsletter.content || newsletter.cleanContent)) {
          newsletter.summary = this.generateSummary(newsletter.content || newsletter.cleanContent || '');
        }
        
        newsletters.push(newsletter);
        
        // Migrate to new schema in the background
        this.migrateToNewSchema(parsed).catch(err => {
          logger.error(`Error migrating newsletter ${id}:`, err);
        });
        
      } catch (error) {
        logger.error(`Error processing old format newsletter ${key}:`, error);
      }
    }
    
    return newsletters;
  }
  

        
        // Create a proper NewsletterMetadata object with all required fields
        const newsletterMetadata: NewsletterMetadata = {
          id: metadata.id || id,
          subject: metadata.subject || '',
          from: metadata.from || metadata.sender || '',  // Ensure 'from' is set
          sender: metadata.sender || '',
          date: metadata.date || new Date().toISOString(),
          url: metadata.url,
          content: metadata.content || '',
          hasFullContent: metadata.hasFullContent === 'true' || metadata.hasFullContent === true,
          metadata: typeof metadata.metadata === 'string'
            ? JSON.parse(metadata.metadata)
            : metadata.metadata || {
              processingVersion: '1.0',
              processedAt: new Date().toISOString()
            },
          summary: metadata.summary,
        }
      };
            
      this.ensureSummary(newsletter);
            
      newsletters.push(newsletter);
            
      // Migrate to new schema in the background
      this.migrateToNewSchema(parsed).catch(err => {
        logger.error(`Error migrating newsletter ${id}:`, err);
      });
            
    }

    // Sort newsletters by date (newest first)
    return newsletters.sort((a, b) => {
      try {
        const dateA = a.date ? new Date(a.date) : null;
        const dateB = b.date ? new Date(b.date) : null;
        
        // Handle cases where dates might be null
        if (!dateA && !dateB) return 0;
        if (!dateA) return 1;  // Put invalid dates at the end
        if (!dateB) return -1; // Put invalid dates at the end
        
        return dateB.getTime() - dateA.getTime();
      } catch (error) {
        logger.error('Error sorting newsletters by date:', error);
        return 0;
      }
    });
  }

  /**
   * Get a single newsletter by ID
   */
  static async getNewsletter(id: string): Promise<Newsletter | null> {
    try {
      // Try old schema first
      const oldKey = `${SCHEMA.NEWSLETTER_PREFIX}${id}`;
      const oldData = await redis.get(oldKey);
      
      if (oldData) {
        const newsletter = typeof oldData === 'string' ? JSON.parse(oldData) : oldData;
        // Migrate to new schema for next time
        await this.migrateToNewSchema(newsletter);
        return newsletter;
      }

      // Try new schema
      const metaKey = `${SCHEMA.META_PREFIX}${id}`;
      const contentKey = `newsletter:content:${id}`;
      
      const [metadata, content] = await Promise.all([
        redis.hgetall(metaKey),
        redis.get(contentKey)
      ]);

      if (metadata && Object.keys(metadata).length > 0) {
        return this.combineNewsletterData(metadata, content);
      }

      return null;
    } catch (error) {
      logger.error(`Error getting newsletter ${id}:`, error);
      return null;
    }
  }

  /**
   * Get full newsletter content by ID
   */
  static async getNewsletterContent(id: string): Promise<string | null> {
    try {
      // Try to get from new schema first
      // Content key is constructed directly
      const contentKey = `newsletter:content:${id}`;
      const content = await redis.get(contentKey);

      if (content) return content;

      // Fallback to old schema
      const oldKey = `${SCHEMA.NEWSLETTER_PREFIX}${id}`;
      const oldData = await redis.get(oldKey);

      if (!oldData) return null;

      // Migrate to new schema
      const newsletter = typeof oldData === 'string' ? JSON.parse(oldData) : oldData;
      await this.migrateToNewSchema(newsletter);

      // Get content from new schema
      return await redis.get(contentKey);
    } catch (error) {
      logger.error(`Error getting newsletter content ${id}:`, error);
      return null;
    }
  }
}